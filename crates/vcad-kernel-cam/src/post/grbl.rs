//! GRBL post-processor for 3-axis CNC mills.

use super::{format_coord, PostProcessor, PostState};
use crate::{ArcDir, ArcPlane, CamSettings, CoolantMode, SpindleDir, ToolEntry, ToolpathSegment};

/// GRBL post-processor configuration.
#[derive(Debug, Clone)]
pub struct GrblPost {
    /// Number of decimal places for coordinates.
    pub precision: usize,
    /// Whether to use line numbers (N codes).
    pub use_line_numbers: bool,
    /// Line number increment.
    pub line_increment: u32,
    /// Whether to use modal feed rates (only emit F when changed).
    pub modal_feed: bool,
    /// Whether to include comments in output.
    pub include_comments: bool,
}

impl Default for GrblPost {
    fn default() -> Self {
        Self {
            precision: 3,
            use_line_numbers: false,
            line_increment: 10,
            modal_feed: true,
            include_comments: true,
        }
    }
}

impl GrblPost {
    /// Create a new GRBL post-processor with default settings.
    pub fn new() -> Self {
        Self::default()
    }

    /// Set coordinate precision.
    pub fn with_precision(mut self, precision: usize) -> Self {
        self.precision = precision;
        self
    }

    /// Enable line numbers.
    pub fn with_line_numbers(mut self) -> Self {
        self.use_line_numbers = true;
        self
    }

    /// Disable comments in output.
    pub fn without_comments(mut self) -> Self {
        self.include_comments = false;
        self
    }

    /// Format a line with optional line number.
    fn format_line(&self, line: &str, state: &mut PostState) -> String {
        if self.use_line_numbers {
            let n = state.line_number;
            state.line_number += self.line_increment;
            format!("N{} {}\n", n, line)
        } else {
            format!("{}\n", line)
        }
    }

    /// Format coordinate value.
    fn coord(&self, value: f64) -> String {
        format_coord(value, self.precision)
    }
}

impl PostProcessor for GrblPost {
    fn header(&self, job_name: &str, settings: &CamSettings) -> String {
        let mut output = String::new();

        // Program header comment
        if self.include_comments {
            output.push_str(&format!("({})\n", job_name));
            output.push_str("(Generated by vcad-kernel-cam)\n");
            output.push('\n');
        }

        // Safety block
        output.push_str("G21\n"); // Metric (mm)
        output.push_str("G90\n"); // Absolute positioning
        output.push_str("G17\n"); // XY plane for arcs
        output.push_str("G40\n"); // Cancel cutter compensation
        output.push_str("G49\n"); // Cancel tool length compensation
        output.push_str("G54\n"); // Work coordinate system 1

        // Move to safe height
        output.push_str(&format!("G0 Z{}\n", self.coord(settings.retract_z)));

        output
    }

    fn tool_change(&self, tool: &ToolEntry, state: &mut PostState) -> String {
        let mut output = String::new();

        if self.include_comments {
            output.push_str(&format!("(Tool {}: {})\n", tool.number, tool.name));
        }

        output.push_str(&format!("T{} M6\n", tool.number));
        state.tool_number = tool.number;

        output
    }

    fn segment(&self, seg: &ToolpathSegment, state: &mut PostState) -> String {
        match seg {
            ToolpathSegment::Rapid { to } => {
                let mut parts = vec!["G0".to_string()];

                // Only output changed coordinates
                if (to[0] - state.x).abs() > 1e-6 {
                    parts.push(format!("X{}", self.coord(to[0])));
                }
                if (to[1] - state.y).abs() > 1e-6 {
                    parts.push(format!("Y{}", self.coord(to[1])));
                }
                if (to[2] - state.z).abs() > 1e-6 {
                    parts.push(format!("Z{}", self.coord(to[2])));
                }

                state.x = to[0];
                state.y = to[1];
                state.z = to[2];

                if parts.len() > 1 {
                    self.format_line(&parts.join(" "), state)
                } else {
                    String::new()
                }
            }

            ToolpathSegment::Linear { to, feed } => {
                let mut parts = vec!["G1".to_string()];

                if (to[0] - state.x).abs() > 1e-6 {
                    parts.push(format!("X{}", self.coord(to[0])));
                }
                if (to[1] - state.y).abs() > 1e-6 {
                    parts.push(format!("Y{}", self.coord(to[1])));
                }
                if (to[2] - state.z).abs() > 1e-6 {
                    parts.push(format!("Z{}", self.coord(to[2])));
                }

                // Feed rate (modal or always)
                if !self.modal_feed || (*feed - state.feed).abs() > 1e-6 {
                    parts.push(format!("F{:.0}", feed));
                    state.feed = *feed;
                }

                state.x = to[0];
                state.y = to[1];
                state.z = to[2];

                if parts.len() > 1 {
                    self.format_line(&parts.join(" "), state)
                } else {
                    String::new()
                }
            }

            ToolpathSegment::Arc {
                to,
                center,
                plane,
                dir,
                feed,
            } => {
                // Set plane if needed (GRBL defaults to G17 XY plane)
                let _plane_code = match plane {
                    ArcPlane::Xy => "G17",
                    ArcPlane::Xz => "G18",
                    ArcPlane::Yz => "G19",
                };

                let arc_code = match dir {
                    ArcDir::Cw => "G2",
                    ArcDir::Ccw => "G3",
                };

                // GRBL uses incremental IJ values (relative to start)
                let i = center[0]; // Already relative in our representation
                let j = center[1];

                let mut parts = vec![arc_code.to_string()];

                parts.push(format!("X{}", self.coord(to[0])));
                parts.push(format!("Y{}", self.coord(to[1])));

                if (to[2] - state.z).abs() > 1e-6 {
                    parts.push(format!("Z{}", self.coord(to[2])));
                }

                parts.push(format!("I{}", self.coord(i)));
                parts.push(format!("J{}", self.coord(j)));

                if !self.modal_feed || (*feed - state.feed).abs() > 1e-6 {
                    parts.push(format!("F{:.0}", feed));
                    state.feed = *feed;
                }

                state.x = to[0];
                state.y = to[1];
                state.z = to[2];

                self.format_line(&parts.join(" "), state)
            }

            ToolpathSegment::Dwell { seconds } => {
                let ms = (seconds * 1000.0) as u32;
                self.format_line(&format!("G4 P{}", ms), state)
            }

            ToolpathSegment::Spindle { rpm, dir } => {
                if *rpm <= 0.0 {
                    state.spindle_on = false;
                    self.format_line("M5", state)
                } else {
                    let m_code = match dir {
                        SpindleDir::Cw => "M3",
                        SpindleDir::Ccw => "M4",
                    };
                    state.spindle_on = true;
                    state.spindle_rpm = *rpm;
                    self.format_line(&format!("{} S{:.0}", m_code, rpm), state)
                }
            }

            ToolpathSegment::Coolant { mode } => {
                let code = match mode {
                    CoolantMode::Off => "M9",
                    CoolantMode::Mist => "M7",
                    CoolantMode::Flood => "M8",
                };
                self.format_line(code, state)
            }

            ToolpathSegment::ToolChange { tool_number } => {
                state.tool_number = *tool_number;
                self.format_line(&format!("T{} M6", tool_number), state)
            }

            ToolpathSegment::Comment { text } => {
                if self.include_comments {
                    format!("({})\n", text)
                } else {
                    String::new()
                }
            }
        }
    }

    fn footer(&self, _state: &PostState) -> String {
        let mut output = String::new();

        output.push_str("M5\n"); // Spindle off
        output.push_str("M9\n"); // Coolant off
        output.push_str("G0 Z25\n"); // Retract
        output.push_str("G0 X0 Y0\n"); // Return to origin
        output.push_str("M30\n"); // Program end

        if self.include_comments {
            output.push_str("(End of program)\n");
        }

        output
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{Tool, Toolpath};

    fn create_test_toolpath() -> Toolpath {
        let mut tp = Toolpath::new();
        tp.push(ToolpathSegment::comment("Test operation"));
        tp.push(ToolpathSegment::rapid(0.0, 0.0, 5.0));
        tp.push(ToolpathSegment::linear(0.0, 0.0, -1.0, 300.0));
        tp.push(ToolpathSegment::linear(50.0, 0.0, -1.0, 1000.0));
        tp.push(ToolpathSegment::linear(50.0, 30.0, -1.0, 1000.0));
        tp.push(ToolpathSegment::rapid(0.0, 0.0, 5.0));
        tp
    }

    #[test]
    fn test_grbl_basic() {
        let post = GrblPost::default();
        let tool = Tool::default_endmill();
        let settings = CamSettings::default();
        let toolpath = create_test_toolpath();

        let gcode = post.generate("test_job", &tool, &toolpath, &settings);

        // Check for expected G-codes
        assert!(gcode.contains("G21")); // Metric
        assert!(gcode.contains("G90")); // Absolute
        assert!(gcode.contains("G0")); // Rapid
        assert!(gcode.contains("G1")); // Linear
        assert!(gcode.contains("M3")); // Spindle on
        assert!(gcode.contains("M5")); // Spindle off
        assert!(gcode.contains("M30")); // Program end
    }

    #[test]
    fn test_grbl_modal_feed() {
        let post = GrblPost::default();
        let mut tp = Toolpath::new();
        tp.push(ToolpathSegment::linear(10.0, 0.0, 0.0, 1000.0));
        tp.push(ToolpathSegment::linear(20.0, 0.0, 0.0, 1000.0)); // Same feed
        tp.push(ToolpathSegment::linear(30.0, 0.0, 0.0, 500.0)); // Different feed

        let tool = Tool::default_endmill();
        let settings = CamSettings::default();

        let gcode = post.generate("test", &tool, &tp, &settings);

        // Count F1000 occurrences - should be 1 (modal)
        let f1000_count = gcode.matches("F1000").count();
        assert_eq!(f1000_count, 1);

        // F500 should appear
        assert!(gcode.contains("F500"));
    }

    #[test]
    fn test_grbl_without_comments() {
        let post = GrblPost::default().without_comments();
        let mut tp = Toolpath::new();
        tp.push(ToolpathSegment::comment("This should not appear"));
        tp.push(ToolpathSegment::rapid(10.0, 0.0, 0.0));

        let tool = Tool::default_endmill();
        let settings = CamSettings::default();

        let gcode = post.generate("test", &tool, &tp, &settings);

        assert!(!gcode.contains("This should not appear"));
    }

    #[test]
    fn test_grbl_with_line_numbers() {
        let post = GrblPost::default().with_line_numbers();
        let mut tp = Toolpath::new();
        tp.push(ToolpathSegment::rapid(10.0, 0.0, 0.0));
        tp.push(ToolpathSegment::rapid(20.0, 0.0, 0.0));

        let tool = Tool::default_endmill();
        let settings = CamSettings::default();

        let gcode = post.generate("test", &tool, &tp, &settings);

        assert!(gcode.contains("N0 ") || gcode.contains("N10 "));
    }

    #[test]
    fn test_grbl_spindle_control() {
        let post = GrblPost::default();
        let mut state = PostState::default();

        // CW spindle
        let out = post.segment(&ToolpathSegment::spindle_on(12000.0, SpindleDir::Cw), &mut state);
        assert!(out.contains("M3"));
        assert!(out.contains("S12000"));

        // CCW spindle
        let out = post.segment(&ToolpathSegment::spindle_on(10000.0, SpindleDir::Ccw), &mut state);
        assert!(out.contains("M4"));

        // Spindle off
        let out = post.segment(&ToolpathSegment::spindle_off(), &mut state);
        assert!(out.contains("M5"));
    }

    #[test]
    fn test_grbl_coolant() {
        let post = GrblPost::default();
        let mut state = PostState::default();

        let out = post.segment(&ToolpathSegment::coolant(CoolantMode::Flood), &mut state);
        assert!(out.contains("M8"));

        let out = post.segment(&ToolpathSegment::coolant(CoolantMode::Mist), &mut state);
        assert!(out.contains("M7"));

        let out = post.segment(&ToolpathSegment::coolant(CoolantMode::Off), &mut state);
        assert!(out.contains("M9"));
    }

    #[test]
    fn test_grbl_dwell() {
        let post = GrblPost::default();
        let mut state = PostState::default();

        let out = post.segment(&ToolpathSegment::dwell(1.5), &mut state);
        assert!(out.contains("G4"));
        assert!(out.contains("P1500")); // 1.5 seconds = 1500ms
    }

    #[test]
    fn test_grbl_precision() {
        let post = GrblPost::default().with_precision(2);
        let mut state = PostState::default();

        let out = post.segment(&ToolpathSegment::rapid(10.123456, 20.987654, 5.555), &mut state);

        // Should have 2 decimal places
        assert!(out.contains("X10.12"));
        assert!(out.contains("Y20.99"));
        assert!(out.contains("Z5.56") || out.contains("Z5.55"));
    }
}
